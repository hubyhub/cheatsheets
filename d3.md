## D3 Einführung

 1. [Säulendiagramm, mit dynamischen Säulen](#bar-chart1)
 2. [Säulendiagramm, mit SVG](#bar-chart2)
 3. [Skalierung in D3](#bar-chart3)
 4. [Ordinal Scale und RangeBande für die x-Achse](#bar-chart4)
 5. [Color Scale](#color-scale)

<a name="bar-chart1"></a>
###  1. Säulendiagramm, mit dynamischen Säulen###
```javascript
var dataset = [5, 10, 15, 17, 25];

d3.select('body').selectAll('div')
.data(dataset)
.enter()
.append('div')
.attr('class','bar')
.style('height', function(d){
 return d*5+'px';
});
```

#### Erklärung:
Der obige Code erzeugt ein simples Säulendiagramm basierend auf dem *dataset*-Array.

**selectAll('div'):** liefert ein Array von allen DIVs die gefunden werden können. Sind keine DIVs innerhalb des body-elements ist das Array leer. 

**data(dataSet, keyFunction)**:  definiert zum einen das **dataSet**-Array, zum anderen die **keyFunction** (optional).

**keyFunction** Die keyFunction bestimmt die Keys für die einzelnen Elemente des **dataSet**-Arrays. 
WIrd **keine** keyFunction angegeben, so sind die Keys automatisch die Indices des dataSet-Arrays. Für [5, 10, 15, 17, 25] wären es [0, 1, 2, 3, 4].
Danach werden die dataSet-Keys mit den Keys der Elemente der **selectAll**-Funktion verglichen. Alle data-keys die *unterschiedlich* sind, werden dann Teil der  **enter**-Selection und in der **enter()**-Funktion aufgerufen. 
Wären etwa 2 DIVs unterhalb vom body-Element vorhanden, dann bekämen diese die Indices [0,1]. 
Dann würde [0,1] mit [0,1,2,3,4] verglichen werden und nur die Datensets mit Index [2,3,4] in die Enter-Selection aufgenommen werden. 

**enter().append('div'):** Die enter().append() Funktion erzeugt dann so viele neue Nodes, wie es Elemente in der Enter-Selection gibt. In diesem Fall werden neue DIVs erzeugt. 

Siehe "[http://knowledgestockpile.blogspot.co.at/](http://knowledgestockpile.blogspot.co.at/2012/01/understanding-selectall-data-enter.html)"

**.attr('class', 'bar'):** damit erzeugt man ein Attribut für jedes Element. Z.B.: eine Klasse,... 

**.style('height', val):** jedem Element kann man nun *styles* geben.
z.B.:  würde `.style('height', '30px')` jedem DIV eine Höhe von 30px geben. Das funktioniert zwar, ist in den meisten Fällen nicht sehr nützlich, weil man ja die Daten des Datensets darstellen möchte. 
Das macht man indem man den String in eine Funktion ändert, der die einzelnen Daten-Werte **d** übergeben werden:
```javascript
.style('height', function(d){
	return d * 5 + 'px';
});
```
Dadurch erhält jede Säule ihre entsprechende Höhe aus dem Datensatz.

<a name="bar-chart2"></a>
###2. Säulendiagramm, mit SVG###
Folgender Sourcecode zeigt das Säulendiagramm in SVG implementiert: 
```javascript
var dataset = [5, 10, 15, 17, 25];
var svg = d3.select('#chartArea').append('svg')
		.attr('width', 400)
		.attr('height', 300);               // bei SVG braucht man keine px angeben.

var multiplier = 9;                         // multiplier

svg.selectAll('rect')                       // rect anstelle div
		.data(dataset)
		.enter()
		.append('rect')                     // rect anstelle div
		.attr('class','bar')
		.attr('x', function(d, i){          // der 2. Parameter in den attr-Funktionen liefert den INDEX des Elements im Dataset.
			return i * 22;                  // Breite der Säule + bißchen mehr
		})
		.attr('y', function(d){
			return 300 - d * multiplier;    // richtet die Säulen von unten des SVG-Elements aus. 
		})
		.attr('width', 20)
		.attr('height', function(d){        // 'height' ist in SVG ein attr und kein style
			return d * multiplier;       	// keine 'px'-Angabe notwendig in SVG
		});
```

Notitz: **multiplier** dient dazu die Säulen skalieren zu können, um z.B. das ganze SVG-Element nutzen zu können. Das ist allerdings nicht die beste Art und Weise. Siehe Kapitel 3.
`return 300 - d * multiplier;` 300 ist höhe des SVG-ELEMENTS, d * multiplier ist Höhe der Säule

Styles für SVG-Elemente definiert man so wie bei HTML per CSS. Allerdings gibt es kleine Unterschiede. So definiert man etwa keine **background-color** sondern  **fill** .

```css 
.bar{
display:inline-block;
width: 20px;
height:75px; // wird von D3 überschrieben
fill: teal;
}
```

<a name="bar-chart3"></a>
###3. Skalierung in D3

**d3.scale**
WIKI: [Skalierung in D3](https://github.com/mbostock/d3/wiki/Scales)

**Scales** sind Funktionen die ein Mapping machen von einer **input-domain** auf eine **output-range**. 

Es gibt unterschiedliche Typen von  Scales.
**Quantitative scales** haben eine kontinuierliche domain, z.B.: ein Set von Zahlen, Daten.
**Ordinal scales** haben eine diskrete domain, z.B.:  ein Set von Namen oder Kategorien. 

**Beispiele:**
```
d3.scale.linear()       
d3.scale.ordinal()     
d3.time.scale()        
```

Scales sind optional, man muß sie nicht verwenden. Nur muß man dann die Mathematik dahinter selber machen.                                                   

**Beispiel:**
```javascript
var dataset = [5, 10, 15, 17, 25];
var w = 400, h = 300;

var svg = d3.select('#chartArea').append('svg')
        .attr('width', w)
        .attr('height', h);               

var yScale = d3.scale.linear()  // SCALE: nimmt einen Wert von einer Input-DOMAIN und mappt ihn auf einen neuen Wert einer Output-RANGE
        .domain([0,25])         // unser Dataset wird auf eine Domain von min 0- 25 max gemappt und je nachdem wo der neue Wert liegt,...
        .range([0,h]);          // ...wird er auf unsere RANGE gemappt. 0 bis zur Höhe

svg.selectAll('rect')                       
        .data(dataset)
        .enter()
        .append('rect')                     
        .attr('class','bar')
        .attr('x', function(d, i){          
        return i * 22;                      
        })
        .attr('y', function(d){
            return h - yScale(d);      
        })
        .attr('width', 20)
        .attr('height', function(d){        
            return yScale(d);             
        });
```

**Erklärung:**
Die Höhe und die y-Koordinate der Säulen wird nun durch die **yScale**-function bestimmt.
Die yScale Function mappt die Werte des datasets LINEAR auf eine DOMAIN und die erhaltenen Werte wiederum auf die angegebene Range.

**Problem:**
Falls das Datenset größere Werte enthält als man in der DOMAIN angegeben hat, werden die Säulen abgeschnitten.
Um das zu verhindern, kann man die obere Grenze der DOMAIN von D3 berechnen lassen:

`d3.max(dataset) // bestimmt den größten Wert im Dataset-Array`

```javascript 
var yScale = d3.scale.linear()  
        .domain([0,d3.max(dataset)])         // die Domain wird nun dynamisch angepasst.
        .range([0,h]);          
```

***Dynamische Farben***

Den Säulen kann man dynamisch, abhängig von ihren Werten im Dataset, eine Farbe zuweisen.
Das kann man auch mit scale.linear() machen:

```
var color = d3.scale.linear()
        .domain([0,d3.max(dataset)])
        .range(["red","green"]);
```

So setzt man die "fill"-Farbe abhängig von der linearen Scale: 

```
.attr('fill',function(d){
            return color(d);
        })
```



<a name="bar-chart4"></a>
### 4. Ordinal Scale und RangeBands für die x-Achse

#### Ordinal Scale
Für ein ordinal skalierbares Merkmal bestehen Rangordnungen der Art „größer“, „kleiner“, „mehr“, „weniger“, „stärker“, „schwächer“ zwischen je zwei unterschiedlichen Merkmalswerten (z. B. x > y > z). 
Über die Abstände zwischen diesen benachbarten Urteilsklassen ist jedoch nichts ausgesagt. 
Meist handelt es sich um qualitative Merkmale, wie z. B. der in der Frage gesuchte „höchste erreichbare Bildungsabschluss“. Ein weiteres Beispiel sind die Schulnoten: Note 1 ist besser als Note 2, man hat aber keine Auskunft darüber, ob der Unterschied zwischen Note 1 und 2 gleich groß ist wie der zwischen Note 3 und Note 4.
Eine Sonderform der Ordinalskala ist die Rangskala. Hierbei kann jeder Wert nur einmal vergeben werden. Beispiele hierfür sind die Erreichung von Rängen im Sport.

**Beispiel:**
```javascript
var dataset = [5, 10, 15, 17, 22];
var w = 400, h = 300;

var svg = d3.select('#chartArea').append('svg')
        .attr('width', w)
        .attr('height', h);

var xScale = d3.scale.ordinal()     // die x-Achse 
        .domain(dataset)            // In unserem Fall ist die DOMAIN das Dataset an sich. Dadurch erzeugt es für jedes Element im Dataset ein Element in der Domain. 
        .rangeBands([0,w],0.25,0);  // [0,w] = Renderbereich; 0.25 = verhältnis balkenbreite/abstand; 0= Außenabstand

var yScale = d3.scale.linear()
        .domain([0,d3.max(dataset)])
        .range([0,h]);

svg.selectAll('rect')
        .data(dataset)
        .enter()
        .append('rect')
        .attr('class','bar')
        .attr('x', function(d){
            return xScale(d);       // x-Koordinate wird von xScale() berechnet.
        })
        .attr('y', function(d){
            return h - yScale(d);
        })
        .attr('width', xScale.rangeBand())  // Balkenbreite wird von xScale.rangeBand() berechnet.
        .attr('height', function(d){
            return yScale(d);       
        });
```

`rangeBands`: Wenn man ein Diagramm baut, möchte man die Balken auf der x-Achse gleich verteilt haben. Man könnte das manuell berechnen (verfügbarer Platz, Balkenbreite, Paddings,..), oder man verwendet `rangeBands`
Es unterteilt den verfügbaren Platz in gleiche Bereiche. 
Siehe: [RangeBands WIKI](https://github.com/mbostock/d3/wiki/Ordinal-Scales#rangeBands)

![RangeBands von d3 wiki](https://f.cloud.github.com/assets/230541/538688/46c298c0-c193-11e2-9a7e-15d9abcfab9b.png)

<a name="color-scale"></a>
###5. Color Scale
